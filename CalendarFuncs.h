#ifndef CALENDAR_FUNCS_H
#define CALENDAR_FUNCS_H

// Generated by AI
#include <time.h>

// Check if a year is a leap year
bool isLeapYear(int year) {
  return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));
}

// Days in each month
int daysInMonth(int month, int year) {
  int daysPerMonth[] = {31,28,31,30,31,30,31,31,30,31,30,31};
  if (month == 2 && isLeapYear(year)) return 29;
  return daysPerMonth[month - 1];
}

// Get the next solstice date (Northern Hemisphere)
struct Solstice {
  int month;
  int day;
};

Solstice getNextSolstice(int year, int month, int day) {
  Solstice summer = {6, 21};  // June solstice
  Solstice winter = {12, 21}; // December solstice

  if (month < summer.month || (month == summer.month && day < summer.day)) {
    return summer;
  } else if (month < winter.month || (month == winter.month && day < winter.day)) {
    return winter;
  } else {
    // Next year's summer solstice
    return summer;
  }
}

// x/365
int calculateDayOfYear(int year, int month, int day) {
  int doy = 0;
  for (int m = 1; m < month; m++) {
    doy += daysInMonth(m, year);
  }
  doy += day;
  return doy;
}

// Calculate ISO week number (week 1 = first week with a Thursday, Monday = first day)
int calculateWeekOfYear(int year, int month, int day) {
  // Create a tm structure
  struct tm timeinfo;
  timeinfo.tm_year = year - 1900;
  timeinfo.tm_mon  = month - 1;
  timeinfo.tm_mday = day;
  timeinfo.tm_hour = 0;
  timeinfo.tm_min  = 0;
  timeinfo.tm_sec  = 0;

  mktime(&timeinfo); // fills tm_wday (0=Sunday, 1=Monday, ...)

  // ISO: Monday=1, Sunday=7
  int weekday = timeinfo.tm_wday == 0 ? 7 : timeinfo.tm_wday;

  // Thursday-based day-of-year
  int doy = calculateDayOfYear(year, month, day);
  int doyThursday = doy + (4 - weekday);

  // Find Jan 1 Thursday-based offset
  struct tm jan1;
  jan1.tm_year = year - 1900;
  jan1.tm_mon  = 0;
  jan1.tm_mday = 1;
  jan1.tm_hour = 0;
  jan1.tm_min  = 0;
  jan1.tm_sec  = 0;
  mktime(&jan1);
  int jan1Weekday = jan1.tm_wday == 0 ? 7 : jan1.tm_wday;

  int week = (doyThursday - (4 - jan1Weekday) + 6) / 7;
  if (week < 1) {
    // Belongs to last week of previous year
    return calculateWeekOfYear(year - 1, 12, 31);
  } else if (week > 52) {
    // Check if this belongs to week 1 of next year
    struct tm dec31;
    dec31.tm_year = year - 1900;
    dec31.tm_mon  = 11;
    dec31.tm_mday = 31;
    dec31.tm_hour = 0;
    dec31.tm_min  = 0;
    dec31.tm_sec  = 0;
    mktime(&dec31);
    int dec31Weekday = dec31.tm_wday == 0 ? 7 : dec31.tm_wday;
    int dec31Doy = calculateDayOfYear(year, 12, 31);
    int dec31Thursday = dec31Doy + (4 - dec31Weekday);
    if (dec31Thursday < doyThursday) week = 1;
  }

  return week;
}

// Calculate days until next solstice
int daysUntilNextSolstice(int year, int month, int day) {
  Solstice next = getNextSolstice(year, month, day);
  int doyToday = calculateDayOfYear(year, month, day);
  int doyNext = calculateDayOfYear(year, next.month, next.day);

  if (doyNext >= doyToday) {
    return doyNext - doyToday;
  } else {
    // Next year's solstice
    int daysInYear = isLeapYear(year) ? 366 : 365;
    return (daysInYear - doyToday) + calculateDayOfYear(year + 1, next.month, next.day);
  }
}

#endif